using System.Data;
using ALE.ETLBox;
using ALE.ETLBox.ConnectionManager;
using ALE.ETLBox.ControlFlow;
using EtlBox.Database.Tests.Attributes;
using EtlBox.Database.Tests.Infrastructure;
using Microsoft.Data.SqlClient;
using Xunit.Abstractions;

namespace EtlBox.Database.Tests.ConnectionManager
{
    [Collection(nameof(DatabaseCollection))]
    public abstract class ConnectionManagerLeaveOpenTests : DatabaseTestBase
    {
        protected ConnectionManagerLeaveOpenTests(
            DatabaseFixture fixture,
            ConnectionManagerType connectionType,
            ITestOutputHelper logger) : base(fixture, connectionType, logger)
        {
            CreateDatabase(Guid.NewGuid().ToString());
        }

        [Fact]
        public void TestLeaveConnectionOpen()
        {
            //Arrange
            var currentConnections = GetOpenConnections();

            var con = GetConnectionManager();
            con.LeaveOpen = true;

            //Act
            Assert.Equal(currentConnections, GetOpenConnections() - 0);
            Assert.True(con.State == null);
            con.Open();
            Assert.True(con.State == ConnectionState.Open);
            Assert.Equal(currentConnections + 1, GetOpenConnections() - 0);
            con.Open();
            Assert.Equal(currentConnections + 1, GetOpenConnections() - 0);
            Assert.True(con.State == ConnectionState.Open);
            Assert.Equal(currentConnections + 1, GetOpenConnections() - 0);
            SqlConnection.ClearAllPools();

            //Assert
            Assert.Equal(currentConnections + 1, GetOpenConnections() - 0);
            con.Close();
            SqlConnection.ClearAllPools();
            Assert.Equal(currentConnections, GetOpenConnections() - 0);
        }

        [Fact]
        public void TestLeaveConnectionOpenWithSqlTask()
        {
            //Arrange
            var initialConnections = GetOpenConnections();
            var con = GetConnectionManager();
            con.LeaveOpen = true;

            //Act
            Assert.Equal(0, GetOpenConnections() - initialConnections);
            Assert.True(con.State == null);
            SqlTask.ExecuteNonQuery(con, "Dummy", "SELECT 1");
            Assert.True(con.State == ConnectionState.Open);
            Assert.Equal(1, GetOpenConnections() - initialConnections);
            SqlTask.ExecuteNonQuery(con, "Dummy", "SELECT 1");
            Assert.Equal(1, GetOpenConnections() - initialConnections);
            Assert.True(con.State == ConnectionState.Open);
            Assert.Equal(1, GetOpenConnections() - initialConnections);
            SqlConnection.ClearAllPools();

            //Assert
            Assert.Equal(1, GetOpenConnections() - initialConnections);
            con.Close();
            SqlConnection.ClearAllPools();
            Assert.Equal(0, GetOpenConnections() - initialConnections);
        }

        [MultiprocessorOnlyFact(
            Skip = "TODO: Fix _connectionManager losing connections after Clone"
        )]
        public void TestLeaveConnectionOpenInParallel()
        {
            Assert.Equal(0, GetOpenConnections());
            //Arrange
            var con = GetConnectionManager();
            con.LeaveOpen = true;
            con.MaxLoginAttempts = 1;

            //Act
            Assert.Throws<InvalidOperationException>(() =>
            {
                try
                {
                    Task t1 = Task.Factory.StartNew(
                        () => SqlTask.ExecuteNonQuery(con, "Dummy", "WAITFOR DELAY '0:00:01.000'")
                    );
                    Task t2 = Task.Factory.StartNew(
                        () => SqlTask.ExecuteNonQuery(con, "Dummy", "WAITFOR DELAY '0:00:01.000'")
                    );
                    t1.Start();
                    t2.Start();
                    Task.WaitAll(t1, t2);
                }
                catch (AggregateException e)
                {
                    if (e.InnerException != null)
                        throw e.InnerException;
                    throw;
                }
            });

            SqlConnection.ClearAllPools();
            con.Close();

            Assert.Equal(2, GetOpenConnections());
        }

        [Fact]
        public void TestCloningIfAllowedConnection()
        {
            //Arrange
            var con = GetConnectionManager();
            con.LeaveOpen = true;

            //Act
            var cloneIfAllowed = con.CloneIfAllowed();
            var clone = con.Clone();

            //Assert
            Assert.Equal(cloneIfAllowed, con);
            Assert.NotEqual(clone, con);
        }

        private int? GetOpenConnections()
        {
            var conString = new SqlConnectionString(_connectionString);
            var master = new SqlConnectionManager(conString.CloneWithMasterDbName());
            var dbName = conString.Builder.InitialCatalog;
            var openConnections = new SqlTask(
                "Count open connections",
                $@"SELECT COUNT(*) as NumberOfConnections 
                    FROM sys.sysprocesses
                    WHERE DB_NAME(dbid) = '{dbName}'"
            )
            {
                ConnectionManager = master,
                DisableLogging = true
            }.ExecuteScalar<int>();
            return openConnections;
        }

        private IConnectionManager GetConnectionManager()
            => _fixture.GetContainer(_connectionType).GetConnectionManager();

        private string _connectionString
            => _fixture.GetContainer(_connectionType).GetConnectionString();

        private void CreateDatabase(string database)
            => _fixture.GetContainer(_connectionType).CreateDatabase(database);

        public class SqlServer : ConnectionManagerLeaveOpenTests
        {
            public SqlServer(DatabaseFixture fixture, ITestOutputHelper logger) : base(fixture, ConnectionManagerType.SqlServer, logger)
            {
            }
        }
    }
}
